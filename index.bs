<pre class='metadata'>
Title: Orchestrator for a decentralized Web network
Shortname: orchestrator
Level: 1
Status: LD
URL: https://mellonscholarlycommunication.github.io/spec-orchestrator
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archiving](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, Ghent University, patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, Ghent University, ruben.dedecker@ugent.be
Editor: Jeroen Werbrouck, Ghent University, Jeroen.Werbrouck@ugent.be
Abstract: This specification describes the implementation requirements for the Ochestrator component.
Markup Shorthands: markdown yes
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table th.last {
  border-right: none;
}
</style>

Set of documents {#set}
=======================

This document is one of the specifications produced by the **ResearcherPod** and **ErfgoedPod** project:

1. [Overview](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/) (this document)
3. [Data Pod](/spec-datapod/)
4. [Rule language](/spec-rulelanguage/)
5. [Artefact Lifecycle Event Log](/spec-eventlog/)
6. [Notifications](/spec-notifications/)
7. [Collector](/spec-collector/)

Introduction {#intro}
=====================

In a [Solid decentralized network](https://solidproject.org/), data, and services the services that use them, do not resort in one place, but are intentionally distributed.
As a result, actors in the network, such as institutions or service providers, need to potentionally involve and communicate with multiple services in order to execute a business process or workflow,
where each services executes a dedicated task (eg. registering or archiving a dataset).
Hence, to avoid excessive manual work, this document specifies the Orchestrator component, which is able to automate such task orchestration.

Network actors maintain their data in a [=Data Pod=],
which is by design a "passive" component: it offers secure data access via Linked Data Platform [[!LDP]] to others, but cannot perform actions such as invoking remote services on the network or reading and writing network content.
These capabilities are therefore delegated to the Orchestrator. On behalf of the actor, the Orchestrator responds to [=triggers=] by executing a number of [=actions=] dictated by a machine-readable [=policy=].
Possible triggers are incoming notifications, perceived changes in the data, or manual invocation by an actor.
Possible actions are sending notifications to other actors, requesting access to resources in a [=Data Pod=], reading data from a [=Data Pod=], or writing data to a [=Data Pod=].

The Orchestrator implements the autonomous agent model: an intelligent software instance that operates on an actor's behalf but without any interference of that actor.
In practice, an Orchestrator is dedicated to a single [=Data Pod=] for which is has access rights to all relevant resources, including the Linked Data Notification [[!LDN]] [=inbox=].
Its autonomy is supplied by the [=Policy=], which dictates business rules in a declarative manner using a [=policy language=].

The remainder of this document specifies the requirements for implementing an [=Orchestrator=] component.

# Definitions

This document uses the following defined terms from [[spec-overview#definitions]]:

- <dfn export>Autonomous Agent</dfn>
- <dfn export>Policy Language</dfn>
- <dfn export>Actor</dfn>
- <dfn export>Artefact</dfn>
- <dfn export>Maintainer</dfn>
- <dfn export>Data Pod</dfn>
- <dfn export>Inbox</dfn>
- <dfn export>Artefact Lifecycle Event Log</dfn>
- <dfn export>Service Hub</dfn>
- <dfn export>Policy</dfn>
- <dfn export>Dashboard</dfn>

# Document Conventions

Within this document, the following namespace prefix bindings are used: 

<table>
  <thead>
    <tr>
      <th>Prefix
      <th>Namespace
  <tbody>
    <tr>
      <td>as
      <td>https://www.w3.org/ns/activitystreams#
    <tr>
      <td>schema
      <td>https://schema.org
    <tr>
      <td>ldp
      <td>http://www.w3.org/ns/ldp#
    <tr>
      <td>acl
      <td>http://www.w3.org/ns/auth/acl#
</table>

High-level overview {#high-level}
=====================

An <dfn export>Orchestrator</dfn> is an [=Autonomous Agent=] that dedicated to a single [=Data Pod=], [=Service Hub=], or any other actor hosting the [=Artefact Lifecycle Event Log=] and a [=Inbox=] resources.
On behalf of that actor, the orchestrator interprets and executes business rules described in a [=policy=] that lead to taking zero or more actions ([[#actions]]) in the network.
It therefore watches the [=Inbox=] for possible triggers ([[#triggers]]), while it records the actions it takes to the to the [=Artefact Lifecycle Event Log=].

## Perspectives

From a [=Data Pod=] perspective,
the [=Orchestrator=] participates in the network on behalf of the [=Data Pod=]'s owner or [=Maintainer=].
At instantiation time,
a [=Maintainer=] connects the [=Orchestrator=] with the [=Artefact Lifecycle Event Log=] and [=Inbox=] resources from its [=Data Pod=],
which it watches in order to receive a possible [=Trigger=].
This an [=Orchestrator=] instance dedicated to a single [=Data Pod=].
From that point on,
the [=Maintainer=] only interacts **indirectly** with the [=Orchestrator=] via the [=Data Pod=], by using a [=Dashboard=] to append the [=Artefact Lifecycle Event Log=] and/or [=Inbox=].

When a trigger arrives,
the [=Orchestrator=] consults the [=policy=] - a set of business rules fixed an maintained by the [=Maintainer=] using the [=Dashboard=],
which results in zero or more [=actions=] to take.
An [=Action=] involves reading resources from or sending notifications to [=data pods=] (including the one it's connected to) or [=Service Hubs=].

The [=Orchestrator=] records every taken [=action=] in the [=data pod=]'s [=Artefact Lifecycle Event Log=].
When the [=Orchestrator=] requires input from the [=Maintainer=],
it can communicate this via the [=Artefact Lifecycle Event Log=],
which is shared with the [=Dashboard=].
The [=Dashboard=] presents this event to the [=Maintainer=] in an actionable way, resulting in a new [=trigger=].

<pre class='include'>
path: images/high-level.svg
</pre>

From a [=Service Hub=] perspective,
the [=Orchestrator=] establishes automated response to notifications from other network [=actors=] and [=orchestrators=] in context of the provided service.
As a possible side-effect, it can also actively consults additional [=actors=] in order to complete the service.
The [=Orchestrator=] responds by delivering a new notification in the [=inbox=] of the actor that invoked the service.
It is the [=policy=] that dictates what response to construct and what consecutive [=actions=] (reading resources from or sending notifications to [=data pods=] or other [=service hubs=]) need to be performed.

<pre class='include'>
path: images/high-level-servicehub.svg
</pre>


## Common interaction pattern

A common activity is the [=Maintainer=] of a [=Data Pod=] invoking a service provided by a [=Service Hub=].
Both [=actors=] can be considered operating an [=orchestrator=] to automate their participation in the network.
Hence, a common interaction pattern is as follows:

1. The [=maintainer=] performs an action that affects or interests other actors in the network (eg. adding a new artefact in the data pod).
2. The [=maintainer=] uses the [=Dashboard=] to reflect this action on the [=Artefact Lifecycle Event Log=] `event log A` that is stored in the [=Data Pod=].
3. The new event triggers the `Orchestrator A` to take consecutive [=action=].
4. `Orchestrator A` consults its `Policy A` for the received [=trigger=], which dictates that it needs to inform the [=service hub=] about the event.
5. `Orchestrator A` sends a notification to `Inbox B` of the [=service hub=].
6. The notification's reception triggers `Orchestrator B` to take consecutive [=action=].
7. `Orchestrator B` consults its `Policy B` for the received [=trigger=], which dictates that it needs to process the artefact and inform the [=maintainer=] about the outcome.
8. `Orchestrator B` processes the contents of the notification using an internal process (eg. index the new artefact in the repository).
9. When completed, `Orchestrator B` adds to `Event log B` that the contents of the notification have been processed.
10. `Orchestrator B` sends a notification to `Inbox A` of the [=maintainer=].
11. `Orchestrator A` adds to `Event log A` that the original event has been processed by the [=service hub=].
12. The [=Dashboard=] displays `Event log A` to the [=maintainer=] to show that the necessary actions have been taken.

<img src="images/high-level-comm.svg" width="600">

Initialization interface {#init}
====================

When deployed, an orchestrator instance requires a minimal set of information in order to function. 
Therefore, it MUST expose a initialization interface so a external actor (eg., a maintainer) is able to supply it. 
This provisioning MUST be possible using a `PUT` or `POST` to a dedicated [[!HTTP11]] resource if the orchestrator is deployed as a web service; see [[#deploy]].
This interface MAY also use an [[LDP#ldpr-resource]] or even [[LDP#ldpr-container]] in case the information is supplied using a description in [[!RDF11-primer]].

<pre class='include'>
path: images/high-level-init.svg
</pre>

First, an Orchestrator MUST allow actors to supply an [[URI]] pointing to an [=inbox=] to watch and read.
In addition, it MAY also allow actors to provide a list of [[LDP#ldpr-resource]] to watch.

Issue: MVS: because I'm not sure it's realistic to poll any HTTP resource, I limited the scope to LDP resources. But even then, I'm not sure how you would do this in practice without keeping a lot of state.

Issue(9): MVS: is this registration of inbox, resources something we want to do at initialization or do we write this in the policy?

Next, Orchestrators solely execute business logic catured in [=policies=].
Thus, they MUST allow actors to supply one or more [[URI]]s pointing to a [=policy=].
These policies MUST be written in the rule language defined in [[spec-rulelanguage]].
An actor SHOULD supply at least one [=policy=] in order to allow the orchestrator to function.

To operate autonomeously, an Orchestrator has to obtain access to some resources in the [=Data Pod=],
which [conforms](https://solidproject.org/TR/protocol#web-access-control) to the Web Access Control specification [[solidwebac]].
Therefore, an orchestrator is a Solid app and MUST be fully compliant with the [[solid-protocol#solid-app]] Client-Side Implementation requirements.
Orchestrators SHOULD also implement [[SOLID-OIDC]] to authenticate to most Solid [=data pods=] and implement the client requirements for [[solidwebac]] to receive authorization, such as checking the `WAC-Allow` header value.

If access is not granted, an Orchestrator MUST request access to the following resources (noted in the [Access Control List (ACL)](http://www.w3.org/ns/auth/acl) ontology):

- `acl:Read` to the [=inbox=] resource (discoverable with `http://www.w3.org/ns/ldp#inbox`)
- `acl:Read` and `acl:Write` to the [=Artefact Lifecycle Event Log=] resource.
- `acl:Read` to any watched [[LDP]] resource.

Issue(#10): are there more necessary authorizations?

Policy {#policy-sec}
=====================

The policy is a set of rules that determines the orchestrator's level of autonomy. 
A rule dictates what [=action=] to take when a [=trigger=] occurs ([[#triggers]]) on behalf of the maintainer.
In practice, the policy reflects a composition of procedures imposed by:

- the institution (ie. the employer of the maintainer and the owner of the artefacts);
- the domain (ie. the broader collaboration context the institution is situated in);
- legislation (ie. the legal obligations);
- or personal preference (ie. the maintainer).

Hence, different policies need to have a common language to achieve interoperability. 
This rule language is described in [spec-rulelanguage].

A orchestrator MUST be able to interpret and executed policies that comply with [spec-rulelanguage].
Requirements regarding [=actions=] and [=triggers=] are discussed in the next sections.

Triggers {#triggers}
=====================

A <dfn>trigger</dfn> is an event to which an orchestrator can respond by taking [=actions=].
An orchestrator MUST respond to the following three types of triggers:

- an new incoming Linked Data Notification [[!LDN]] in the [=inbox=]
- an observed state changes to watched [=data pod=] resources
- a scheduled trigger from the internal time-based event scheduler

A trigger MUST be identifyable by a [[!URI]], such that the rules written in the [[spec-rulelanguage]] can refer to its occurence.

Issue: define something like a trigger description?

## Receving Linked Data Notifications ## {#trigger-ldn}

Sending a Linked Data Notification is the primary way to provoke action from the Orchestrator. 
Common senders of notifications are:
- a [=maintainer=] by using the [=Dashboard=], who performed a manual operation on a artefact (eg. creating a new artefact) and wants to trigger consecutive action (eg. announcing that artefact);
- a [=service hub=] or other [=actor=] who has performed an operation related to an artefact (eg. created a comment about that artefact) stored in the maintainer's data pod and is therefore of potential interest to the orchestrator.

To be able to read the notifications from an [=inbox=],
An orchestrator MUST be a compliant [[LDN#consumer]].
It MAY watch zero or more advertise inboxes, as mentioned in [[#init]] and MUST retrieve incoming Linked Data Notifications from all advertised inboxes.
Inboxes MAY be authenticated according to [[LDN#authenticated-inboxes]], which is discussed further in [[#security-considerations]].

The definitions of all possible [[!LDN]] notifications using the [[!ACTIVITYSTREAMS-VOCABULARY]] are listed in the [[spec-notifications]]. 
An orchestrator MUST at least support the following subset:

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)

Issue(8): What notifications do NOT trigger the orchestrator?

When receiving a notification, the orchestrator validates the received notification to all notification-based triggers mentioned in its [=policy=].
Linked Data Notification triggers SHOULD be defined as RDF data shapes, compliant to the [[!SHACL]] specification. 
The shape definitions MAY also conform to the \[SHEX](https://shex.io/) language.


<div class=example>
Example of a Linked Data Notifications trigger using SHACL:
```
ex:LDNTriggerShape
  a sh:NodeShape ;
  sh:targetClass as:Create ;    # Applies to all create notifications
  sh:property [                 # _:b1
    sh:path as:actor ;          # only select triggers from organizations
    sh:maxCount 1 ;
    sh:class schema:Organization ;
    sh:nodeKind sh:IRI ;
  ] ;
  sh:property [                 # _:b2
    sh:path as:object ;         # only select triggers about dataset
    sh:maxCount 1 ;
    sh:class schema:Dataset ;
    sh:nodeKind sh:IRI ;
  ] ;
  sh:closed true ;
  sh:ignoredProperties ( rdf:type ) .
```
</div>

## Observing resource state changes  ## {#trigger-resource}

An orchestrator can also watch LDP resources ([[[LDP#ldpr]]) (e.g, by means of polling) whose state changes issue a trigger.
Hence, an orchestrator MUST accept resource stage changes of [[LDP#ldpr]] as triggers for policy actions.
In case the observed [[[LDP#ldpr]] is also a LDP container ([[LDP#ldpc]]), 
the orchestrator MUST observe state changes for all [[LDP#ldpr]] that are contained by the observed [[LDP#ldpc]].
The Orchestrator MUST request `acl:Read` access all observed [[[LDP#ldpr]] as noted in [[#init]].

At least following state changes MUST issue a trigger:
	- Update of a resource by observing a change in the `Last-Modified` or `ETag` headers.
	- Deletion of a resource by observing a `4XX` status code

Issue: Make resource state changes more concrete: how exactly using HTTP, eg. last modified

In case of an [[LDP#ldpc]], 
the creation or deletion of a container member MUST also issue a trigger.
Thus, the orchestrator SHOULD observe a difference in the set of `?resource` bindings by matching the triple pattern `?container ldp:contains ?resource` on the container's response.


## Scheduled trigger ## {#trigger-schedule}

Finally, some triggers might be configured as recurrent and activate the orchestrator on scheduled intervals.
Therefore, an Orchestrator MUST accept triggers from a time-based job scheduler such as [[cron]]. 

Scheduled trigger can be configured using the crontab; an orchestrator MUST be able to interpret the pattern syntax defined in [[!cron]].
A trigger MUST invoke an action on every matching pattern during the time the trigger is active and the orchestrator is running.

<div class=example>
```
# Issue trigger every weekday morning at 3:15 am

ex:trigger ex:pattern "15 3 * * 1-5"^^ex:crontab
```
</div>

Issue(11): How can you communicate a scheduled trigger from a institutional perspective? for instance, researchers all apply the institutional 

Actions {#actions}
=====================

An <dfn>action</dfn> is a form of interation with other actors or resources in the network.
An Orchestrator performs such [=actions=] on behalf of a network [=actor=].

There are three types of actions that an orchestrator MUST support:
-  sending Linked Data Notifications [[!LDN]] to an [=inbox=] resource, likely belonging to a [=Service Hub=] or [=Data Pod=].
-  manipulating [[!LDP]] resources of a [=Data Pod=].
-  reading arbitrary [[!HTTP11]] resources

## Sending Linked Data notifications

Sending a Linked Data Notification is the primary way to provoke action from other actors in the network. 
Hence, an orchestrator MUST be a compliant [[LDN#sender]].

From the list of possible [[!LDN]] notifications in [[spec-notifications]],
an orchestrator MUST at least be able to send the following subset:

- [as:Create](https://www.w3.org/ns/activitystreams#Create)
- [as:Announce](https://www.w3.org/ns/activitystreams#Announce)
- [as:Update](https://www.w3.org/ns/activitystreams#Update)
- [as:Delete](https://www.w3.org/ns/activitystreams#Delete)
- [as:Undo](https://www.w3.org/ns/activitystreams#Undo)
- [as:Accept](https://www.w3.org/ns/activitystreams#Accept)
- [as:Reject](https://www.w3.org/ns/activitystreams#Reject)

## Reading HTTP resources

A second type of action is reading [[HTTP11]] resources.
Thus, an orchestrator MUST be able to construct a `GET` request.

Issue: does this make sense?

## Manipulating LDP resources

A final action is performing create, read, update and delete operations on a [[LDP#ldpr]] and [[LDP#ldpc]]
Therefore, an Orchestrator MUST be a [[LDP#dfn-ldp-client]] and implement at least the verbs `PUT`, `PATCH` and `DELETE`.

Issue: TODO

- Read: `GET`

## Action descriptions

When a policy rule executed in response to a [=trigger=], it produces zero or more actions.
Each of these actions is captured in a <dfn>action description</dfn>, which uses a simple vocabulary:

: Class
:: `act:Action`
: Subclasses 
:: `act:NotifyAction` | `act:HTTPAction`
: Properties
:: `act:payload` | `act:target` | `act:description`

This vocabulary MUST be interpretable by the orchestrator and MUST result in an executed action.
The specific requirements are discussed per action type below.

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/vocabulary/act/context",
  "type": "NotifyAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/inbox",
  "payload": {
	  "@type": "as:Create",
	  ...
  }
}
```
</div>

<div class='example'>
```
{
  "@context": "https://mellonscholarlycommunication.github.io/context",
  "type": "HttpAction",
  "description": "Notify service hub of artefact creation.",
  "target": "https://servicehub.org/resource",
  "payload": {
	  "@type": "http:Request", 
	  "http:methodName": "POST",
	  ...
  }
}
```
</div>

Deploying an orchestrator {#deploy}
=====================

An Orchestrator MUST be deployable as a <dfn export>local background process</dfn> or as a <dfn export>remote web service</dfn>.
In case of the latter, an actor SHOULD be able to spawn, initialize and trigger the instance over [[!HTTP11]], as defined in [[#deploy]] and [[#triggers]].
The Orchestrator MAY also serve an [=inbox=] for communicating with third-parties using Linked Data Notifications [[LDN]] .

Example of spawning an orchestrator using Linked Data Notifications:
```

POST /inbox HTTP/1.1
Host: example.org
Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"
Content-Language: en

{
  "@context": "https://www.w3.org/ns/activitystreams",
  "summary": "Spawn orchestrator",
  "type": "Create",
  "actor": "http://kb.nl#me",
  "object": "http://example.org/orchestrator/1"
}
```

If deployed as a [=local background process=], an (custom) API MUST be present that is able perform these actions.


Security considerations {#security-considerations}
==================================================

## Authenticated Inboxes
In case the Orchestrator supports [triggers from incoming Linked Data Notifications](#trigger-ldn), the Orchestrator SHOULD make use of [authenticated inboxes](https://www.w3.org/TR/ldn/#authenticated-inboxes) as described by the [Linked Data Notifications](https://www.w3.org/TR/ldn/) specification.
Requiring authentication on the pod inbox can prevent unwanted parties from forging notifications to be processed by the Orchestrator.

## Signed notifications
Instead of requiring authentication to post notifications to the pod inbox, the Orchestrator may require notifications to be singed by the sender before accepting notifications.
There was an upcoming panel on signed notifications - TODO



Appendix A: Implementation details {#implementation-details}
============================================================

## Retrieving inbox notifications

## Observing LDP resource state updates

## Time based trigger implementations


<pre class=biblio>
{
	"solid-oidc": {
		"authors": [
			"Aaron Coburn (Inrupt)",
			"elf Pavlik",
			"Dmitri Zagidulin"
		],
		"href": "https://solid.github.io/authentication-panel/solid-oidc/",
		"title": "SOLID-OIDC",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
	"solid-protocol": {
		"authors": [
			"Sarven Capadisli",
			"Tim Berners-Lee",
			"Ruben Verborgh",
			"Kjetil Kjernsmo",
			"Justin Bingham",
			"Dmitri Zagidulin"
		],
		"href": "https://solidproject.org/TR/protocol/",
		"title": "The Solid Protocol",
		"status": "Editor’s Draft",
		"publisher": "Solid project",
		"deliveredBy": [
			"https://www.w3.org/community/solid/"
		]
	},
  "spec-overview": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-overview/",
		"title": "Overview of the ResearcherPod specifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-rulelanguage": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-rulelanguage/",
		"title": "Rule language for decentralized business processes",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "spec-notifications": {
		"authors": [
      "Miel Vander Sande",
      "Patrick Hochstenbach",
      "Ruben Dedecker",
      "Jeroen Werbrouck",
      "Herbert Van de Sompel"
    ],
		"href": "http://mellonscholarlycommunication.github.io/spec-notifications/",
		"title": "List of notifications",
		"status": "Editor’s Draft",
		"publisher": "ResearcherPod and ErfgoedPod project"
	},
  "cron": {
		"authors": ["The Open Group"
    ],
		"href": "https://pubs.opengroup.org/onlinepubs/9699919799/",
		"title": "crontab - schedule periodic background work",
		"status": "Standard",
		"publisher": "IEEE"
	}
}
</pre>
